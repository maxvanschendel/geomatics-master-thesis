\subsection{Map Extraction}
In the map extraction module we extract topometric maps from each individual partial point cloud map. In this subsection we will discuss the algorithms and data structures used for this purpose.

\subsubsection{Overview}
The goal of the map extraction step is to transform a partial voxel grid map \(\voxelgrid\) into a topometric map \(\topometricmap\). It works by first finding a navigation graph \(\navgraph\) that connects a subset of the partial map \(\voxelgrid_{navigation} \in \voxelgrid\), which represents the parts of the map that a hypothetical agent would use to move through the environment, including the floor, stairs and ramps. We then use \(\navgraph\) along with \(\voxelgrid\) to segment the map into semantically meaningful rooms based on clusters of visibility, we denote the segmented voxel grid map as \(\voxelgrid_{room}\). After doing so we construct the topological graph \(\topologicalgraph\) of the environment by finding which rooms are adjacent in \(\navgraph\). Finally, we fuse the topological map with the segmented room map to construct the topometric map \(\topometricmap\). Figure \ref{fig:map_extract_steps} shows an overview of our map extraction algorithm, its input, and (intermediate) outputs. In the rest of this subsection we will discuss each of steps in more detail.

\begin{figure}[h]
    \centering
    \includegraphics*[width=\textwidth]{./fig/map_extract.png}
    \caption{Diagram showing map extraction processes and intermediate data.}
    \label{fig:map_extract_steps}
\end{figure}

\subsubsection{Navigable volume}
In our first step we extract a navigation graph \(\navgraph\). The navigation graph tells us how a theoretical agent in the map's environment would navigate through that environment. In practice, this means the areas of the floor, ramps and stairs that are at a sufficient distance from a wall and a ceiling. We compute \(\navgraph\) using a three step algorithm.

\subsubsection{Convolution}
The first step uses voxel convolution with a stick-shaped kernel \(\mathcal{K}_{stick}\) (shown in \ref{fig:stick_kernel}) to find all voxels that are unobstructed and are thus candidates for navigation. Each voxel in the kernel has a weight of 1, except the origin voxel which has weight 0. The associated function is summation. Convolving the voxel grid's occupancy property with the stick kernel results in voxels with an obstructed value of 0 when no other voxels are in the stick kernel. This indicates that these voxels have enough space around and above them to be used for navigation. We denote this convolution as \(\mathcal{V}_{\mathcal{K}_{stick}} = c(\mathcal{V},\mathcal{K}_{stick})\). We then filter out all non-zero voxels, such that \(\mathcal{V}_{unobstructed}=\{\boldsymbol{v} \in \mathcal{V}_{\mathcal{K}_{stick}}\ |\ \mathcal{V}_{obstructed}(\boldsymbol{v}) = 0\}\). 

\begin{figure}[h]
    \centering
    \includegraphics*[width=0.5\textwidth]{./fig/structuring_element.png}
    \caption{Illustration of stick kernel with top and side views.}
    \label{fig:stick_kernel}
\end{figure}

\subsubsection{Dilation}
The next step of the algorithm is to dilate the unobstructed voxels upwards by a distance \(d_{dilate}\). This connects the unoccupied voxels separated by a small height differences into a connected volume. The value of \(d_{dilate}\) depends on the expected differences in height between the steps of stairs in the environment. Typically, we use a value of 0.2m for this parameter. The result is a new voxel grid \(\mathcal{V}_{dilated}\). Note that the dilation step may create new occupied voxels that are not in the original voxel grid, which means that \(\mathcal{V}_{dilated}\) is not a subset of \(\voxelgrid\).

\subsubsection{Connected components}
The final step of the algorithm is to split \(\mathcal{V}_{dilated}\) into one or more connected components. A connected component \(\mathcal{V}_c\) of a voxel grid is a subset of \(\mathcal{V}\) where there exists a path between every voxel in \(\mathcal{V}_c\). The neighbourhood graph \(\mathcal{G}_{\mathcal{V},\ \mathcal{K}} = (V,\ E)\) of \(\mathcal{V}\) represents the voxels in \(\mathcal{V}\) as nodes. Each node has incident edges towards all other voxels in its neighbourhood, which is defined by a kernel \(\mathcal{K}\), such that \(V = \mathcal{V},\ E_{V} = \{(\boldsymbol{v}, \boldsymbol{v_{nb}})\ |\ \boldsymbol{v} \in \mathcal{V},\ \boldsymbol{v_{nb}} \in \mathcal{K}_{\boldsymbol{v}}\},\ |E_{V}| \leq |\mathcal{K}|*|\mathcal{V}|\). 

There exists a path between two voxels \(\boldsymbol{v_a},\ \boldsymbol{v_b}\) in \(\mathcal{V}\) if there exists a path between their corresponding nodes \(V_a,\ V_b\) in \(\mathcal{G}_{\mathcal{V}}\). We denote the set of all possible paths between two nodes as \(paths(V_a,\ V_b)\). A connected component is then defined as \(\mathcal{V}_c=\{\boldsymbol{v_a}\ |\ \boldsymbol{v_a} \in \mathcal{V},\ \boldsymbol{v_b} \in \mathcal{V},\ |paths(V_a, V_b)| \neq 0\}\). We define the set of all connected components as \(\mathcal{V}_{cc}=\{\mathcal{V}_{c,\ i}\}_{i=1}^n\). We find the connected components using the following algorithm:

\begin{algorithm}
    \caption{Region growing connected components}\label{alg:cap}
    \begin{algorithmic}

    \Require \quad Voxel grid \(\mathcal{V}\)
    \Require \quad Connectivity kernel \(\mathcal{K}\)
    \Ensure \quad Connected components \(\mathcal{V}_{cc}\)

    \State \(\mathcal{G}_{\mathcal{V},\ \mathcal{K}} = (V,\ E),\ V \in \mathcal{V}\) \Comment{Convert voxel grid to neighbourhood graph using specified kernel}
    \State \(V_{unvisited} = V\)
    \State \(\mathcal{V}_{cc} = \{\}\)
    
    \State \(i = 0\)
    \While{$|V_{visited}| \neq 0$}
        \State Select random node \(n\) from \(V_{unvisited}\)
        \State \(n_{BFS} = BFS(n)\) \Comment{Use breadth-first search to find all nodes connected to \(n\)}
        \State Remove \(n_{BFS}\) from \(V_{unvisited}\)
        \State \(\mathcal{G}_i = (n_{BFS},\ E)\)
        \State Add \(\mathcal{V}_{c,\ i}\) to \(\mathcal{V}_{cc}\)
        \State \(i = i + 1\)
    \EndWhile
    \end{algorithmic}
\end{algorithm}

After doing so, we find the connected component in \(\mathcal{V}_{cc}\) with the largest amount of voxels \(\mathcal{V}_{max}\), which corresponds to the voxels used for navigation. The navigation graph \(\navgraph\) is the neighbourhood graph of \(\mathcal{V}_{max}\). We denote the intersubsection of the navigation graph's nodes and the whole voxel grid map as \(\mathcal{V}_{navigation} = \mathcal{V}_{max} \cap \mathcal{V}\).

\subsubsection{Maximum visibility estimation}
To compute the isovists necessary for room segmentation it is first necessary to estimate hypothetical scanning positions that maximize the view of the map. We compute these by finding the local maxima of the horizontal distance field of \(\mathcal{V}_{navigation}\). The steps to achieve this are as follows. 

\subsubsection{Horizontal distance field}
For each voxel in \(\voxelgrid\) we compute the horizontal Manhattan distance to the nearest boundary voxel. A boundary voxel is a voxel for which not every voxel in its Von Neumann neighbourhood is occupied. To compute this value we iteratively convolve the voxel grid with a circle-shaped kernel on the X-Z plane, where the radius of the circle is expanded by 1 voxel with each iteration, starting with a radius of 1. When the number of voxel neighbours within the kernel is less than the number of voxels in the kernel a boundary voxel has been reached. Thus, the number of radius expansions tells us the Manhattan distance to the boundary of a particular voxel. We denote the horizontal distance of a voxel to its boundary as \(dist: \mathbb{Z}^{3+} \mapsto \mathbb{Z}\). Computing the horizontal distance for every voxel in \(\voxelgrid\) gives us the horizontal distance field (HDF), such that \(HDF = \{dist(\voxel) \mid \voxel \in \voxelgrid\}\). We denote the horizontal distance of a given voxel \(\voxel\) as \(d_{\voxel}\). We implement this using the following algorithm.

\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

\begin{algorithm}
    \caption{Horizontal distance field}
    \begin{algorithmic}

    \Require \quad Navigation voxel grid \(\mathcal{V}_{navigation}\)
    \Ensure \quad Horizontal distance field \(HDF = \{dist(\voxel) \mid \voxel \in \voxelgrid_{navigation}\}\)

    \\

    \ForEach {$\boldsymbol{v} \in \mathcal \voxelgrid_{navigation} $}
        \State \(r=1\)
        \State Create \(\mathcal{K}_{circle}\) with radius \(r\)
        \While{$convolve(\boldsymbol{v},\ \mathcal{K}_{circle}) = |\mathcal{K}_{circle}|)$}
            \State \(r = r+1\)
            \State Expand \(\mathcal{K}_{circle}\) with new radius \(r\)
        \EndWhile

        \State \(HDF = HDF \cup {r}\) \Comment{Add voxel's radius to horizontal distance field}
    \EndFor
    \end{algorithmic}
\end{algorithm}

We then find the maxima of the horizontal distance field within a given radius \(r \in \mathbb{R}\).  The local maxima of the horizontal distance field are all voxels that have a larger or equal horizontal distance than all voxels within \(r\), such that \(HDF_{max} = \{\voxel \mid dist(\voxel) \geq max \{dist(\boldsymbol{v_{r}} \mid \boldsymbol{v_{r}} \in radius(\voxel,\ r))\}\}\). Increasing the value of \(r\) reduces the number of local maxima and vice versa. All voxels in \(HDF_{max}\) lie within the geometry of the environment, which means the view of the environment is blocked by the surrounding voxels. To solve this, we take the centroids of the voxels in \(HDF_{max}\) and translate them upwards to a reasonable scanning height \(h\), to estimate the positions with the optimal view of the map. We denote these positions as \(views = \{\boldsymbol{v_c} + (0, h, 0) \mid \boldsymbol{v} \in HDF_{max}\}\). We use the following algorithm to compute \(views\).

\begin{algorithm}
    \caption{Horizontal Distance Field Maxima}
    \begin{algorithmic}

    \Require \quad Navigation voxel grid \(\mathcal{V}_{navigation}\)
    \Require \quad Horizontal distance field \(HDF\)
    \Require \quad Radius \(r \in \mathbb{R}^+\)
    \Require \quad Scanning height \(h \in \mathbb{R}\)

    \Ensure \quad Estimated optimal views $views \in \mathbb{R}^3$

    \\

    \State $views = \{\}$

    \ForEach {$\boldsymbol{v} \in \mathcal \voxelgrid_{navigation} $}
        \State \(neighbourhood = radius(\boldsymbol{v},\ r)\)
        \If{$d_{\voxel} \geq \max{\{d_{nb} \mid neighbourhood\}}$} \Comment{Check if voxel's horizontal distance is equal or greater than the horizontal distance of every voxel in its neighbourhood}
            \State $views = views \cup \{centroid(\voxel) + (0, h, 0)\}$
        \EndIf
    \EndFor
    
    \end{algorithmic}
\end{algorithm}

\begin{figure}[h]
    \centering
    \includegraphics*[width=0.8\textwidth]{./fig/hdf_simple.png}
    \caption{Illustration of horizontal distance field computation and extraction of local maxima.}
    \label{fig:hdf_simple}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics*[width=0.7\textwidth]{./fig/horizontal_distance_field.png}
    \caption{Resulting horizontal distance field of partial map, with resultant optimal view points shown in red.}
    \label{fig:hdf}
\end{figure}

\subsubsection{Visibility}
The next step in the room segmentation algorithm is to compute the visibility from each position in \(views\). We denote the all voxels that are visible from a given position as \(visibility: \mathbb{R},\ \voxelset \mapsto \mathbb{Z}^{m \times 3},\ m \in \mathbb{R},\ n \geq m\). A target voxel is visible from a position if a ray cast from the position towards the centroid of the voxel does not intersect with any other voxel. To compute this we use the digital differential analyzer (DDA) algorithm to rasterize the ray onto the voxel grid in 3D. We then check if any of the voxels that the ray enters- except the target voxel- is occupied. If none are, the target voxel is visible from the point. We perform this raycasting operation from every position in \(views\) towards every voxel within a radius \(r_{visibility}\) of that position. Only taking into account voxels within a radius speeds up the visibility computation, and is justifiable based on the fact that real-world 3D scanners have limited range. We denote the set of visibilities from each point in views as \(visibility_{views} = \{visibility(\boldsymbol{x}) \mid \boldsymbol{x} \in views\}\). The below pseudocode shows how the visibility computation works.

\begin{algorithm}
    \caption{Visibility}
    \begin{algorithmic}

    \Require \quad Voxel grid \(\voxelgrid\)
    \Require \quad Origin \(o \in \mathbf{R}^3\)
    \Require \quad Range \(r_{visibility} \in \mathbb{R}^+\)
    \Ensure \quad $visibility \in \mathbb{Z}^{3}$

    \State $visibility = \{\voxel_c \mid \voxel_c \in radius(o, r_{visibility}) \land DDA(\voxelgrid,\ o,\ centroid(\voxel_c)) = \voxel_c\}$

    \end{algorithmic}
\end{algorithm}

% https://math.stackexchange.com/questions/83990/line-and-plane-intersubsection-in-3d
\begin{algorithm}
    \caption{DDA (Digital Differential Analyzer)}
    \begin{algorithmic}

    \Require \quad Voxel grid \(\voxelgrid\)
    \Require \quad Ray origin \(\boldsymbol{o} \in \mathbf{R}^3, \boldsymbol{o} \in [\voxelgrid_{min}, \voxelgrid_{max}]\)
    \Require \quad Ray target \(\boldsymbol{t} \in \mathbf{R}^3\)

    \Ensure \quad $hit \in \mathbb{Z}^{3}$ \Comment{First encountered collision}

    \State $\boldsymbol{p}_{current} = \boldsymbol{o}$
    \State $\voxel_{\boldsymbol{o}} = (\boldsymbol{o} - \voxelgrid_{min})//\voxelgrid_{e}$
    \State $\voxel_{current} = \voxel_{\boldsymbol{o}}$

    \State $\boldsymbol{d} = (\boldsymbol{t} - \boldsymbol{o})$ 
    \State $heading = \boldsymbol{d} \odot abs(\boldsymbol{d})^{-1}$ \Comment{Determine if ray points in positive or negative direction for every axis}

    \While{$(\voxel_{current} \notin \voxelgrid \lor \voxel_{current} = \voxel_{\boldsymbol{o}}) \land \boldsymbol{p}_{current} \in [\voxelgrid_{min}, \voxelgrid_{max}]$}
        \State $\boldsymbol{c} = centroid(\voxel_{current})$
        \State $d_{planes} = \boldsymbol{c} + heading*\voxelgrid_{e}/2$

        \State $d_{min} = \infty$
        \State $axis=1$

        \ForEach($d \in d_{planes}$)
            \State $t = \frac{d - \boldsymbol{n} \cdot \boldsymbol{p}_{current}}{\boldsymbol{n} \cdot (\boldsymbol{t} - \boldsymbol{p}_{current})}$
            \State $\boldsymbol{i} = \boldsymbol{p}_{current} + t(\boldsymbol{t} - \boldsymbol{o})$

            \If{$d_{min} \geq t$}
                \State $\boldsymbol{p}_{current} = \boldsymbol{i}$
                \State $\voxel_{current,\ axis} += heading_{axis}$
            \EndIf

            \State $axis=axis+1$
        \EndFor

    \State $hit = \voxel_{current}$
    \EndWhile

\end{algorithmic}
\end{algorithm}

\subsubsection{Room segmentation}
After computing the set of visibilities from the estimated optimal views we apply clustering to group the visibilities by similarity. This is based on the definition of a room as a region of similar visibility. Remember that each visibility is a subset of the voxel grid map. To compute the similarity of two sets we use the Jaccard index, which is given by \(J(A,B) = \frac{|A \cap B|}{|A \cup B|}\). Computing the Jaccard index for every combination of visibilities gives us a similarity matrix \(S^{n \times n} \in [0, 1]\). The similarity matrix is symmetric because \(J(A,B) = J(B,A)\). Its diagonals are 1, as \(J(A,A) = 1\). An example similarity matrix is showin in figure \ref{fig:jaccard}.

\begin{figure}
    \centering
    \includegraphics*[width=0.8\textwidth]{./fig/mutual_visibility_matrix.png}
    \caption{Similarity matrix extracted from set of visibilities. Each value represents the Jaccard index of two visibilities.}
    \label{fig:jaccard}
\end{figure}

We can also consider \(S^{n \times n}\) as an undirected weighted graph \(\graph_S\), where every node represents a visibility and the edges the Jaccard index of two visibilities. This means we can treat visibility clustering as a weighted graph clustering problem. To solve this problem we used the Markov Cluster (MCL) algorithm (CITE MCL), which has been shown by previous research to be state-of-the-art for visibility clustering. 


The main parameter of the MCL algorithm is inflation. By varying this parameter between an approximate range of \([1.2, 2.5]\) we get different clustering results. We find the optimal value for inflation within this range by maximizing the clustering's modularity. This value indicates the difference between the fraction of edges within a given cluster and the expected number of edges for that cluster if edges are randomly distributed. 

% TODO: Give mathematical description of MCL
% TODO: Give mathematical equation of modularity

We denote the clustering of \(visibility_{views}\) that results from the MCL algorithm as \(\mathbf{C}_{visibility} = \{c_0, c_1, \dots c_{n-1}, c_{n}\},\ n=|views|,\ c \in \integers,\ n \geq c\), where \(n\)th element of \(\mathbf{C}_{visibility}\) is the cluster that the \(n\)th element of \(visibility_{views}\) belongs to, such that for a given value of \(c\), the elements in \(visibility_{views}\) for which the corresponding \(c\) in \(\mathbf{C}_{visibility}\) has the same value belong to the same cluster. As each visibility is a subset of the map, each cluster of visibilities is also a subset of the map. We denote the union of the visibilities belonging to each cluster as \(\mathcal{V}_{c}\). 

It is possible for visibility clusters in \(\mathcal{V}_{c}\) to have overlapping voxels. This means that each voxel in the partial map may have multiple associated visibility clusters. However, the goal is to assign a single room to each voxel in the map. To solve this we assign to each voxel the cluster in which the most visibilities contain that voxel. The result is a mapping from voxels to visibility clusters (which we will from now on refer to as rooms), which we denote as \(room: \voxel \mapsto \integers\), such that \(room(\voxel) = c,\ c \in \mathbf{C}_{visibility},\ \voxel \in \voxelgrid\). This often results in noisy results, with small, disconnected islands of rooms surrounded by other rooms. Intuitively, this does not correspond to a reasonable room segmentation. To solve this, we apply a label propagation algorithm. This means that for every voxel we find the voxels within a neighbourhood as defined by a convolution kernel. We then assign to the voxel the most common label, in this case the room, of its neighbourhood, if that label is more common than the current label. We iteratively apply this step until the assigned labels stop changing. Depending on the size of the convolution kernel the results are smoothed and small islands are absorbed by the surrounding rooms.


\begin{algorithm}
    \caption{Label propagation}
    \begin{algorithmic}

    \Require \quad Voxel grid \(\voxelgrid\)
    \Require \quad Initial labeling \(label^{(0)}: \mathbb{Z}^{3+} \mapsto \mathbb{Z}\)
    \Require \quad Kernel \(\mathcal{K}\)
    \Ensure \quad Propagated labeling after \(t\) steps \(label^{(t)}: \mathbb{Z}^{3+} \mapsto \mathbb{Z}\)

    \State $t=0$

    \While($label^{(t)} \neq label^{(t+1)}$) \Comment{Keep iterating until labels stop changing}
        \ForEach($\voxel \in \voxelgrid$)
            \State $L = \{label^{(t)}(\voxel_{nb}) \mid \voxel_{nb} \in neighbours(\voxel, \mathcal{K})\}$4

            \State $l_{max} = \mathop{argmax}_{l} \ |\{l \mid l \in L\}|$ \Comment{Most common label in neighbourhood}
            \State $l_{current} = label^{(t)}(\voxel)$  \Comment{Label of current voxel}

            \If{$|\{l \mid l \in L \land l=l_{max}\}| > |\{l \mid l \in L \land l=l_{current}|$}
                \State \(label^{(t+1)}(\voxel) = l_{max}\)
            \Else
                \State \(label^{(t+1)}(\voxel) = label^{(t)}(\voxel)\)
            \EndIf
        \EndFor

        \State $t = t+1$ \Comment{Use propagated labeling as input for next iteration}
    \EndWhile
    \end{algorithmic}
\end{algorithm}

\subsubsection{Topometric map extraction}
The above steps segment the map into multiple non-overlapping rooms based on visibility clustering. In the next step we transform the map into a topometric representation \(\topometricmap = (\topologicalgraph, \voxelgrid)\), which consists of a topological graph \(\topologicalgraph=(V,E)\) and a voxel grid map \(\voxelgrid\). Each node in \(\topologicalgraph\) represents a room, and also has an associated voxel grid which is a subset of \(\voxelgrid\) and represents the geometry of that room. Edges in \(\topologicalgraph\) represent navigability between rooms, meaning that there is a path between them on the navigable volume that does not pass through any other rooms. This means that for two rooms to have a navigable relationship they need to have adjacent voxels that are both in the navigable volume. To construct the topometric map we thus add a node for every room in the segmented map with its associated voxels, we then add edges between every pair of nodes that satisfy the above navigability requirement.  


\begin{algorithm}
    \caption{Topology extraction}
    \begin{algorithmic}

    \Require \quad Voxel grid \(\voxelgrid\)
    \Require \quad Voxel grid navigation subset \(\voxelgrid_{navigation}\)
    \Require \quad Room segmentation \(room: \voxel \mapsto \integers\)
    \Require \quad Adjacency kernel $\mathcal{K}_{adjacency}$

    \Ensure \quad Topological spatial graph \(\widetilde{\mathcal{G}}_{topology} = (V_{topology},\ E_{topology})\)
    \Ensure \quad Node embedding \(f_{node}: V \mapsto \mathbb{R}^3\)

    \State $\widetilde{\mathcal{G}}_{topology} = (\{\},\ \{\})$

    \State Get each unique room label \(\mathbf{R} = \{room(\voxel) \mid \voxel \in \voxelgrid\}\)
    \State Split \(\voxelgrid\) by label, such that \(\mathbf{V} = \{\voxelgrid \cap \{\voxel \mid \voxel \in \voxelgrid \land room(\voxel) = r\} \mid r \in \mathbf{R}\}\)
    \State Store room label associated with each voxel grid \(room_{\voxelgrid}: r \mapsto \voxelgrid\)
    \State $V_{topology} = \mathbf{V}$
    \State $f_{node}(v) = centroid(v),\ v \in V_{topology}$

    \ForEach($\voxel \in \voxelgrid_{navigation}$)
        \State $v_r = room(\voxel)$
        \State $nbs_r = \{room(nb) \mid nb \in neighbourhood(\voxel,\ \mathcal{K}_{adjacency})\}$

        \State $r_{adjacency} = \{(r_a,\ r_b) \mid (r_a,\ r_b) \in {v_r} \times {nbs_r} \land r_a \neq r_b\}$
        \State $E_{topology} = E_{topology} \cup \{(room_{\voxelgrid}(r_a),\ room_{\voxelgrid}(r_b)) \mid (r_a,\ r_b) \in r_{adjacency}\}$
    \EndFor
    \end{algorithmic}
\end{algorithm}