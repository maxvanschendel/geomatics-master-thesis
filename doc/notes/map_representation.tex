\subsection{Map Representations}

\subsubsection{Point Cloud}
An unordered collection of points representing the geometry of an object or environment in 3D euclidean space, defined as \(\mathcal{P}=\{p_i\}_{i=1}^n, p_i \in \mathbb{R}^3\), where \(n\) denotes the number of points \citep{volodine_point_2007}.

\subsubsection{Voxel Grid}
A voxel is the 3D equivalent of a pixel. A voxel represents a single cell in a bounded 3D volume divided into a regular grid, a voxel grid, and its associated properties. For example, a voxel may contain information about whether it is occupied and what its color is. We consider a voxel as a three-dimensional vector representing its coordinates along the x, y and z axes of the voxel grid. 

To generate a voxel grid we divide a 3D axis-aligned volume \(V\), defined by minimum and maximum bounds \(V_{min}, V_{max} \in \mathbb{R}^{3}\) into a grid of cubic cells with edges of length \(e_{l} \in \mathbb{R}^+\). A voxel $\boldsymbol{v} = (x, y, z) \in \mathbb{Z^{3+}}$ represents a subvolume of \(V\) bounded by a single cell. The minimum and maximum bounds of this subvolume are given by \(\boldsymbol{v_{min}} = V_{min} + \boldsymbol{v}*e_{l}\), and \(\boldsymbol{v_{max}} = V_{min} + (\boldsymbol{v}+1)*e_{l}\). The voxel's centroid is given by \(\boldsymbol{v_c} = (\boldsymbol{v_{min}} + \boldsymbol{v_{max}})*0.5\). Given a point \(\boldsymbol{p}\) within the bounds of \(V\), the corresponding voxel is given by \(\boldsymbol{v_p} = (\boldsymbol{p} - V_{min})//e_l\), where \(//\) denotes integer division. A property of a voxel is given by the function \(\mathcal{V}_{property}: \mathbb{Z}^{3+} \mapsto \mathbb{R}^{m*n}\).

Due to the regularly spaced nature of the voxel grid a voxel coordinate only consists of integer values. Voxel \(\boldsymbol{v_{V_{min}}} = (0,0,0)\) represents the first cell along each of the voxel grid's axes and the minimum of the volume's bounds, voxel represents \((0,1,1)\) the first cell along the x and the second along the y and z axes, etc. We also restrict voxel coordinates to only be positive as negative coordinates would fall outside of the bounds of the volume. For the same reason, a voxel's coordinates can not be larger than that of the voxel representing the volume's maximum bounds \(\boldsymbol{v_{V_{max}}} = (V_{max} - V_{min})//e_l\). We define a voxel grid as a set of occupied voxels \(\mathcal{V}=\{v_{i}\}_{i=1}^{n},\ n \in [1, \prod{\boldsymbol{v_{V_{max}}}}]\) with an associated bounded volume \(V_{\mathcal{V}}\) and edge length \(e_{l}\). Figure \ref{fig:vg_basic} shows an example voxel grid and its components.

\begin{figure}[h]
    \centering
    \includegraphics*[width=\textwidth]{./fig/voxels_basic.png}
    \caption{A voxel grid and its components.}
    \label{fig:vg_basic}
\end{figure}

\paragraph{Sparse Voxel Octree}
Several operations on voxel grids benefit from using a spatial index, including range searching, radius searching and level of detail generation. We use a data structure called a sparse voxel octree (SVO) to achieve this. A normal octree recursively subdivides a volume into 8 cells, called octants. This operation results in a tree data structure, with nodes representing octants at a certain level of subsidivision. The root node of the tree structure represents the entire volume while the leaf nodes represent batches of 1 or more data points. In the case of a voxel octree, the leaf nodes represent individual voxels. In a sparse voxel octree only the octants which are occupied are represented in the tree. 

To generate the SVO we first create a Morton Order for the voxel grid. A Morton order maps the three-dimensional coordinates of the voxels to one dimension while preserving locality. It does by interleaving the binary coordinates into a single binary number, called a Morton code. The ordered vector of Morton codes gives the Morton order. We define the Morton order of a voxel grid as \(M_{\mathcal{V}}=\{m_i\}_{i=1}^{|\mathcal{V}|},\ m_i < m_{i+1},\ m_i \in \mathbb{Z^+}\). We then divide the Morton order into buckets with width 8, such that each bucket contains at most 8 Morton codes, with a maximum difference of 8, in Morton order. Each non-empty bucket represents a parent node of at most 8 child nodes in the octree. By recursively performing this step until only one bucket remains, the root node, a sparse voxel octree is constructed. 

We denote the function that returns all \(n\) voxels within range \(r\) of a voxel as \(radius: \mathbb{Z}^{3+},\ \mathbb{R} \mapsto \voxelset\).

\paragraph{Voxel convolution}
Voxel convolution involves moving a sliding window, or kernel, over each voxel in the grid to retrieve its neighbourhood and then computing a new value for the voxel based on computing a function \(\mathcal{K}_f: \mathcal{K}_w \mapsto \mathbb{R}^{m*n}\) over its neighbours. The neighbourhood can be a radius around the voxel, its Von Neumann neighbourhood, its Moore neighbourhood, or any other arbitrary shape. We can define a kernel \(\mathcal{K}\) as a voxel grid, with an associated weight for each voxel \(weight: \mathbb{Z}^{3+} \mapsto \mathbb{R},\ v \in {\mathcal{K}}\) and an origin voxel \(\boldsymbol{o_{\mathcal{K}}} \in \mathbb{Z^{3}}\). To apply a kernel to a voxel we first translate the kernel so that its origin lies on the voxel, such that \(\mathcal{K}_{\boldsymbol{v}} = \{\boldsymbol{v_{\mathcal{K}}} + (\boldsymbol{v} - \boldsymbol{o_{\mathcal{K}}})\ |\ \boldsymbol{v_{\mathcal{K}}} \in \mathcal{K}\}\). We then get the property which we wish to convolve of each neighbour and multiply it by the neighbour's weight, such that \(\mathcal{K}_{w} = \{weight(\boldsymbol{v}) * \mathcal{V}_{property}(\boldsymbol{v})\ |\ \boldsymbol{v} \in \mathcal{K}_{v} \cap \mathcal{V}\}\). The property after convolution is then given by \(\mathcal{K}_f(\mathcal{K}_{w})\). We denote the convolution of a property of every voxel in \(\mathcal{V}\) with \(\mathcal{K}\) as \(\mathcal{V}_{property,\  \mathcal{K}} = c(\mathcal{V}_{property},\mathcal{K})\). If the property is left out it is implied to be occupancy.


\paragraph{Voxel hashing}
%TODO: WRITE subsection

\subsubsection{Topological map}
A hybrid map representation combining both the topological and metric characteristics of the environment. This map representation allows the end-user to use either topological or metric information depending on the needs of the situation, e.g. the topological layer can be used for large-scale navigation and abstract reasoning while the metric layer can be used for landmark detection or obstacle avoidance. In the context of this thesis a topological-metric map refers to a 3D representation of an environment containing both a metric occupancy grid map \(\mathbb{M}_M\) representing its geometry and a spatial graph \(\widetilde{\mathbb{M}_T}=(V, E)\) representing its topology. Each vertex \(v \in V\) has an associated variable \(m(v)\) representing a subset of the full metric map describing that place, such that \(m(v) \subset \mathbb{M}_M\).

\subsubsection{Topometric map}
Topological maps are a qualitative graph representation of an environment's structure, where vertices represent locally distinctive places, often rooms, and edges represent traversable paths between them  (see figure \ref{fig:topo_ex}) \citep{thrun_learning_1998,kuipers_robust_1988}. Topological maps are inspired by the fact that humans are capable of spatial learning despite limited sensory and processing capability and only having partial knowledge of the environment. This is based on observations that cognitive maps, the mental maps used by humans to navigate within an environment, consist of multiple layers with a topological description of the environment being a fundamental component \citep{kuipers_robust_1988,kuipers_modeling_1978}. We denote the topology of an environment as a graph \(G\), where vertices \(V\) represent \(n\) distinctive places \(v_i\) and edges \(E\) represent the presence of \(m\) traversable paths between neighbouring pairs of places \(\{v_j,v_k\}\), such that \(G=(V, E)\), \(V=\{v_i\}_{i=1}^n, E=\{\{v_j,v_k\}_i\}_{i=1}^m, v_j \in V, v_k \in V\). In the context of indoor mapping the graph is often embedded in 2D or 3D euclidean space as a spatial graph. Given the embedding \(f : G \rightarrow R^n\), \( \widetilde{G}:=f(G)\), we denote \(\widetilde{G}\) as the spatial graph of \(G\) \citep{kobayashi_spatial_1994}. Each vertex in \(\widetilde{G}\) has an associated 3D coordinate describing its position in the coordinate frame of the map. If the specific paths between vertices are known they can be associated with the edges in \(\widetilde{G}\), otherwise an edge only represents a possible path between two points in space.