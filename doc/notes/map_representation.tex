\subsection{Map Representations}
In this section we will give a description of the different kinds of 3D map representation that are used in this research, their mathematical notation, and the operations that we perform on them.

\subsubsection{Point Cloud}
An unordered collection of points representing the geometry of an object or environment in 3D euclidean space \citep{volodine_point_2007}.

\begin{equation}
\mathcal{P}=\{p_i\}_{i=1}^n, p_i \in \mathbb{R}^3
\end{equation}

Where \(\mathcal{P}\) denotes the point cloud and \(n\) the number of points.

\subsubsection{Voxel Grid}
A voxel is the 3D equivalent of a pixel. A voxel represents a single cell in a bounded 3D volume divided into a regular grid, a voxel grid, and its associated properties. For example, a voxel may contain information about whether it is occupied and what its color is. We consider a voxel as a three-dimensional vector representing its coordinates along the x, y and z axes of the voxel grid. 

To generate a voxel grid we divide a 3D axis-aligned volume \(V\), defined by minimum and maximum bounds \(V_{min}, V_{max} \in \mathbb{R}^{3}\) into a grid of cubic cells with edges of length \(e_{l}\). A voxel represents a subvolume of \(V\) bounded by a single cell. A voxel coordinate only consists of integer values that represent multiples of the edge length along each dimension. Voxel \(\boldsymbol{v_{V_{min}}} = (0,0,0)\) represents the first cell along each of the voxel grid's axes and the minimum of the volume's bounds, voxel represents \((0,1,1)\) the first cell along the x and the second along the y and z axes, etc. We also restrict voxel coordinates to only be positive as negative coordinates would fall outside of the bounds of the volume. For the same reason, a voxel's coordinates can not be larger than that of the voxel representing the volume's maximum bounds \(\boldsymbol{v_{V_{max}}} = (V_{max} - V_{min})\ //\ e_l\), where \(//\) denotes integer division. 
\begin{equation}
\boldsymbol{v} = (x, y, z) \in \mathbb{Z}^{3+}
\end{equation}
\begin{equation}
    \label{eq:vmin}
\boldsymbol{v}_{min} = V_{min} + \boldsymbol{v}*e_{l}
\end{equation}
\begin{equation}
    \label{eq:vmax}
\boldsymbol{v}_{max} = \boldsymbol{v}_{min} + e_{l}
\end{equation}

The minimum and maximum bounds of this subvolume are given by equation \ref{eq:vmin} and \ref{eq:vmax}. The voxel's centroid is given by \ref{eq:vc}. Given a point \(\boldsymbol{p}\) within the bounds of \(V\), the corresponding voxel is given by equation \ref{eq:vp} . 
\begin{equation}
    \label{eq:vc}
    \boldsymbol{v_c} = (\boldsymbol{v_{min}} + \boldsymbol{v_{max}})*0.5
\end{equation}
\begin{equation}
    \label{eq:vp}
    \boldsymbol{v_p} = (\boldsymbol{p} - V_{min})\ //\ e_l
\end{equation}


\begin{figure}[h]
    \centering
    \includegraphics*[width=\textwidth]{./fig/voxels_basic.png}
    \caption{A voxel grid and its components.}
    \label{fig:vg_basic}
\end{figure}

A property of a voxel is given by equation \ref{eq:vproperty}. We define a property as an \(m\) by \(n\) real matrix for the purposes of this research. However, in reality a property could be any value. For example, we denote the property \textit{occupied}, which can be either 1 or 0, of a voxel \(\voxel\) as \(V_{occupied}(\voxel) = \voxel_{occupied} = \begin{pmatrix} 1 \end{pmatrix} | \begin{pmatrix} 0 \end{pmatrix}\)

\begin{equation}
    \label{eq:vproperty}
    \mathcal{V}_{property}: \mathbb{Z}^{3+} \mapsto \mathbb{R}^{m*n},\ \mathcal{V}_{property}(\boldsymbol{v}) = \boldsymbol{v}_{property}
\end{equation}

We define a voxel grid as a set of occupied voxels with an associated bounded volume \(V_{\mathcal{V}}\) and edge length \(e_{l}\), as shown in equation \ref{eq:voxelgrid}. Figure \ref{fig:vg_basic} shows an example voxel grid and its components.

\begin{equation}
    \label{eq:voxelgrid}
    \mathcal{V}=\{\voxel_{i}\}_{i=1}^{n},\ n \in [1, \prod{\boldsymbol{v_{V_{max}}}}]
\end{equation}


\paragraph{Sparse Voxel Octree}
Several operations on voxel grids benefit from using a spatial index, including range searching, radius searching and level of detail generation. We use a data structure called a sparse voxel octree (SVO) to achieve this. A normal octree recursively subdivides a volume into 8 cells, called octants. This operation results in a tree data structure, with nodes representing octants at a certain level of subsidivision. The root node of the tree structure represents the entire volume while the leaf nodes represent batches of 1 or more data points. In the case of a voxel octree, the leaf nodes represent individual voxels. In a sparse voxel octree only the octants which are occupied are represented in the tree. 

To generate the SVO we first create a Morton Order for the voxel grid. A Morton order maps the three-dimensional coordinates of the voxels to one dimension while preserving locality. It does by interleaving the binary representation of the voxel's coordinates into a single binary string which is interpreted as a positive integer. This is a Morton code. The ordered vector of Morton codes gives us the Morton order. We denote the Morton order of a voxel grid according to equation \ref{eq:morton}

\begin{equation}
    \label{eq:morton}
    M_{\mathcal{V}}=\{m_i\}_{i=1}^{|\mathcal{V}|},\ m_i < m_{i+1},\ m_i \in \mathbb{Z^+}
\end{equation}
    
We divide the Morton order into buckets with size 8, such that each bucket contains at most 8 Morton codes, with a maximum difference of 8, in Morton order. Each non-empty bucket represents a parent node of at most 8 child nodes in the octree. By recursively performing this step until only one bucket remains, the root node, a sparse voxel octree is constructed. 

We denote the function that returns all \(n\) voxels within range \(r\) of a voxel as follows.

\begin{equation}
    radius: \mathbb{Z}^{3+},\ \mathbb{R} \mapsto \voxelset
\end{equation}

\paragraph{Voxel convolution}
Voxel convolution involves moving a sliding window, or kernel, over each voxel in the grid to retrieve its neighbourhood and then computing a new value for the voxel based on computing a function  over its neighbours.
\begin{equation}
    \label{eq:convolution}
    \mathcal{K}_f: \mathcal{K}_w \mapsto \mathbb{R}^{m*n}
\end{equation}

The neighbourhood can be a radius around the voxel, its Von Neumann neighbourhood, its Moore neighbourhood, or any other arbitrary shape. We can define a kernel \(\mathcal{K}\) as a voxel grid, with an associated weight for each voxel  and an origin voxel.
\begin{equation}
weight: \mathbb{Z}^{3+} \mapsto \mathbb{R},\ v \in {\mathcal{K}}
\end{equation}
\begin{equation}
\boldsymbol{o}_{\mathcal{K}} \in \mathbb{Z}^{3}
\end{equation}

To apply a kernel to a voxel we first translate the kernel so that its origin lies on the voxel.

\begin{equation}
    \label{eq:kv}
\mathcal{K}_{\boldsymbol{v}} = \{\boldsymbol{v_{\mathcal{K}}} + (\boldsymbol{v} - \boldsymbol{o_{\mathcal{K}}})\ |\ \boldsymbol{v_{\mathcal{K}}} \in \mathcal{K}\}
\end{equation}

We then get the property which we wish to convolve of each neighbour and multiply it by the neighbour's weight.
\begin{equation}
    \label{eq:kw}
    \mathcal{K}_{w} = \{weight(\boldsymbol{v})\mathcal{V}_{property}(\boldsymbol{v})\ |\ \boldsymbol{v} \in \mathcal{K}_{v} \cap \mathcal{V}\}
\end{equation}

The property after convolution is then given by \(\mathcal{K}_f(\mathcal{K}_{w})\). We denote the convolution of a property of every voxel in \(\mathcal{V}\) with \(\mathcal{K}\) as follows.

\begin{equation}
    \label{eq:c}
    \mathcal{V}_{property,\  \mathcal{K}} = c(\mathcal{V}_{property},\mathcal{K})
\end{equation}

If the property is left out it is implied to be occupancy.


\subsubsection{Topological map}
Topological maps are a qualitative graph representation of an environment's structure, where vertices represent locally distinctive places, often rooms, and edges represent traversable paths between them  (see figure \ref{fig:topo_ex}) \citep{thrun_learning_1998,kuipers_robust_1988}. Topological maps are inspired by the fact that humans are capable of spatial learning despite limited sensory and processing capability and only having partial knowledge of the environment. This is based on observations that cognitive maps, the mental maps used by humans to navigate within an environment, consist of multiple layers with a topological description of the environment being a fundamental component \citep{kuipers_robust_1988,kuipers_modeling_1978}. We denote the topology of an environment as a graph \(G\), where nodes \(N\) represent distinctive places \(n\) and edges \(E\) represent the presence of a path between neighbouring pairs of places \((v_j,v_k)\) that does not pass through any other places.

\begin{equation}
    \label{eq:G}
    G=(N, E)
\end{equation}
\begin{equation}
    \label{eq:V}
    N=\{n_i\}_{i=1}^k
\end{equation}
\begin{equation}
    \label{eq:E}
    E=\{(n_j,n_k)_i\}_{i=1}^m, n_j \in N,\ n_k \in N
\end{equation}

In the context of indoor mapping the graph is often embedded in 2D or 3D euclidean space as a spatial graph. We denote he spatial graph of \(G\) as \(\widetilde{G}\). Each vertex in \(\widetilde{G}\) has an associated 3D coordinate describing its position in the coordinate frame of the map. 

\subsubsection{Topometric map}
A hybrid map representation combining both the topological and metric characteristics of the environment. This map representation allows the end-user to use either topological or metric information depending on the needs of the situation, e.g. the topological layer can be used for large-scale navigation and abstract reasoning while the metric layer can be used for landmark detection or obstacle avoidance. In the context of this thesis a topometric map refers to a 3D representation of an environment containing both a metric voxel grid map representing its geometry and a topological graph representing the adjacency relationship between distinctive places. 

\begin{equation}
    \label{eq:topometricmap}
    \topometricmap = (\voxelgrid,\ G),\ \voxelgrid=\{\voxel_{i}\}_{i=1}^{n}
\end{equation}
\begin{equation}
    \label{eq:place_subset}
    G=(N,\ E),\ N=\{n_i\}_{i=1}^k,\ n \subset \voxelgrid
\end{equation}

Each node \(n \in N\) has an associated variable \(m(v)\) representing a subset of the full metric map describing that place.
