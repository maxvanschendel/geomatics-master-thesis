\section{Map Representations}

\subsection{Point Cloud}

\subsection{Voxel Grid}
A voxel is the 3D equivalent of a pixel. A voxel represents a single cell in a bounded 3D volume divided into a regular grid, a voxel grid, and its associated properties. For example, a voxel may contain information about whether it is occupied and what its color is. We consider a voxel as a three-dimensional vector representing its coordinates along the x, y and z axes of the voxel grid. 

To generate a voxel grid we divide a 3D axis-aligned volume \(V\), defined by minimum and maximum bounds \(V_{min}, V_{max} \in \mathbb{R}^{3}\) into a grid of cubic cells with edges of length \(e_{l} \in \mathbb{R}^+\). A voxel $\boldsymbol{v} = (x, y, z) \in \mathbb{Z^{3+}}$ represents a subvolume of \(V\) bounded by a single cell. The minimum and maximum bounds of this subvolume are given by \(\boldsymbol{v_{min}} = V_{min} + \boldsymbol{v}*e_{l}\), and \(\boldsymbol{v_{max}} = V_{min} + (\boldsymbol{v}+1)*e_{l}\). The voxel's centroid is given by \(\boldsymbol{v_c} = (\boldsymbol{v_{min}} + \boldsymbol{v_{max}})*0.5\). Given a point \(\boldsymbol{p}\) within the bounds of \(V\), the corresponding voxel is given by \(\boldsymbol{v_p} = (\boldsymbol{p} - V_{min})//e_l\), where \(//\) denotes integer division. A property of a voxel is given by the function \(\mathcal{V}_{property}: \mathbb{Z}^{3+} \mapsto \mathbb{R}^{m*n}\).

Due to the regularly spaced nature of the voxel grid a voxel coordinate only consists of integer values. Voxel \(\boldsymbol{v_{V_{min}}} = (0,0,0)\) represents the first cell along each of the voxel grid's axes and the minimum of the volume's bounds, voxel represents \((0,1,1)\) the first cell along the x and the second along the y and z axes, etc. We also restrict voxel coordinates to only be positive as negative coordinates would fall outside of the bounds of the volume. For the same reason, a voxel's coordinates can not be larger than that of the voxel representing the volume's maximum bounds \(\boldsymbol{v_{V_{max}}} = (V_{max} - V_{min})//e_l\). We define a voxel grid as a set of occupied voxels \(\mathcal{V}=\{v_{i}\}_{i=1}^{n},\ n \in [1, \prod{\boldsymbol{v_{V_{max}}}}]\) with an associated bounded volume \(V_{\mathcal{V}}\) and edge length \(e_{l}\).

\subsubsection{Sparse Voxel Octree}
Several operations on voxel grids benefit from using a spatial index, including range searching, radius searching and level of detail generation. We use a data structure called a sparse voxel octree (SVO) to achieve this. A normal octree recursively subdivides a volume into 8 cells, called octants. This operation results in a tree data structure, with nodes representing octants at a certain level of subsidivision. The root node of the tree structure represents the entire volume while the leaf nodes represent batches of 1 or more data points. In the case of a voxel octree, the leaf nodes represent individual voxels. In a sparse voxel octree only the octants which are occupied are represented in the tree. 

To generate the SVO we first create a Morton Order for the voxel grid. A Morton order maps the three-dimensional coordinates of the voxels to one dimension while preserving locality. It does by interleaving the binary coordinates into a single binary number, called a Morton code. The ordered vector of Morton codes gives the Morton order. We define the Morton order of a voxel grid as \(M_{\mathcal{V}}=\{m_i\}_{i=1}^{|\mathcal{V}|},\ m_i < m_{i+1},\ m_i \in \mathbb{Z^+}\). We then divide the Morton order into buckets with width 8, such that each bucket contains at most 8 Morton codes, with a maximum difference of 8, in Morton order. Each non-empty bucket represents a parent node of at most 8 child nodes in the octree. By recursively performing this step until only one bucket remains, the root node, a sparse voxel octree is constructed. 

We denote the function that returns all \(n\) voxels within range \(r\) of a voxel as \(radius: \mathbb{Z}^{3+},\ \mathbb{R} \mapsto \voxelset\).

\subsubsection{Voxel convolution}
Voxel convolution involves moving a sliding window, or kernel, over each voxel in the grid to retrieve its neighbourhood and then computing a new value for the voxel based on computing a function \(\mathcal{K}_f: \mathcal{K}_w \mapsto \mathbb{R}^{m*n}\) over its neighbours. The neighbourhood can be a radius around the voxel, its Von Neumann neighbourhood, its Moore neighbourhood, or any other arbitrary shape. We can define a kernel \(\mathcal{K}\) as a voxel grid, with an associated weight for each voxel \(weight: \mathbb{Z}^{3+} \mapsto \mathbb{R},\ v \in {\mathcal{K}}\) and an origin voxel \(\boldsymbol{o_{\mathcal{K}}} \in \mathbb{Z^{3}}\). To apply a kernel to a voxel we first translate the kernel so that its origin lies on the voxel, such that \(\mathcal{K}_{\boldsymbol{v}} = \{\boldsymbol{v_{\mathcal{K}}} + (\boldsymbol{v} - \boldsymbol{o_{\mathcal{K}}})\ |\ \boldsymbol{v_{\mathcal{K}}} \in \mathcal{K}\}\). We then get the property which we wish to convolve of each neighbour and multiply it by the neighbour's weight, such that \(\mathcal{K}_{w} = \{weight(\boldsymbol{v}) * \mathcal{V}_{property}(\boldsymbol{v})\ |\ \boldsymbol{v} \in \mathcal{K}_{v} \cap \mathcal{V}\}\). The property after convolution is then given by \(\mathcal{K}_f(\mathcal{K}_{w})\). We denote the convolution of a property of every voxel in \(\mathcal{V}\) with \(\mathcal{K}\) as \(\mathcal{V}_{property,\  \mathcal{K}} = c(\mathcal{V}_{property},\mathcal{K})\). If the property is left out it is implied to be occupancy.


\subsubsection{Voxel hashing}
%TODO: WRITE SECTION

\subsection{Topometric map}