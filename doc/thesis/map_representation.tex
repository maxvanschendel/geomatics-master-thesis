\subsection{Map Representations}
In this section we will give a description of the different kinds of map representation that are used in this research, their mathematical notation, and the operations that we perform on them.

\subsubsection{Point Cloud}
An unordered collection of points representing the geometry of an object or environment in 3D euclidean space \citep{volodine_point_2007}.

\begin{equation}
\mathcal{P}=\{p_i\}_{i=1}^m, p_i \in \mathbb{R}^3
\end{equation}

Where \(\mathcal{P}\) denotes the point cloud and \(n\) the number of points that it contains.

\subsubsection{Voxel Grid}
A voxel is the 3D equivalent of a pixel. A voxel represents a single cell in a bounded 3D volume divided into a regular voxel grid. A voxel represents information about its volume, such as whether it is occupied, what color it is, or any other property. Unless otherwise specified, voxels in this research represent whether a given volume is occupied by any kind of obstruction, such as an object or the environment. A voxel can be represented by a three-dimensional vector containing its coordinates along the x, y and z axes of the voxel grid, as shown in equation \ref{eq:voxel_coords}. 

\begin{equation}
    \label{eq:voxel_coords}
    \boldsymbol{v} = (x, y, z)^T \in \mathbb{N}^{3}
\end{equation}

We define a \gls{voxelgrid} as a set of voxels with an associated size \(e_{l}\), as shown in equation \ref{eq:voxelgrid}. Unoccupied voxels are not present in the set, making it a sparse representation. Figure \ref{fig:vg_basic} shows an example voxel grid and its components.

\begin{equation}
    \label{eq:voxelgrid}
    \mathcal{V}=\{\voxel_{i}\}_{i=1}^{n}
\end{equation}

To generate a voxel grid we divide a 3D axis-aligned volume bounding box  defined by minimum and maximum bounds \(\mathbf{b}_{min}, \mathbf{b}_{max} \in \mathbb{R}^{3}\) into a grid of cubic cells with distance \(e \in \mathbb{R}^+\) between their centers. A voxel represents a subvolume of the bounding box bounded by a single cell. A voxel coordinate only consists of integer values that represent the position of the voxel in the grid along each axis. Voxel \(\boldsymbol{u} = (0,0,0)^T\) represents the first cell along each of the voxel grid's axes and the minimum of the volume's bounds, voxel \((0,1,1)^T\) represents the first cell along the x- and the second along the y- and z-axes, etc. We also restrict voxel coordinates to only be positive as negative coordinates would fall outside of the bounds of the volume. For the same reason a voxel's coordinates can not be larger than that of the voxel representing the volume's maximum bounds \(\boldsymbol{w} = (\mathbf{b}_{max} - \mathbf{b}_{min})\ \rfloor \ e\), where \(\rfloor\) denotes floor division. 


\begin{equation}
    \label{eq:vmin}
\boldsymbol{v}_{min} = \mathbf{b}_{min} + \boldsymbol{v}e
\end{equation}
\begin{equation}
    \label{eq:vmax}
\boldsymbol{v}_{max} = \boldsymbol{v}_{min}+e
\end{equation}

The minimum and maximum bounds of this subvolume are given by equation \ref{eq:vmin} and \ref{eq:vmax}. The voxel's centroid is given by equation \ref{eq:vc}. Given a point \(\boldsymbol{p}\) within the bounds of \(V\), the corresponding voxel is given by equation \ref{eq:vp} . 
\begin{equation}
    \label{eq:vc}
    \boldsymbol{v_c} = (\boldsymbol{v_{min}} + 0.5\boldsymbol{v_{max}})
\end{equation}
\begin{equation}
    \label{eq:vp}
    \boldsymbol{v_p} = (\boldsymbol{p} - \mathbf{b}_{min})\ \rfloor\ e_l
\end{equation}


\begin{figure}[h]
    \centering
    \includegraphics*[width=\textwidth]{./fig/voxel_basics.pdf}
    \caption{A voxel grid and its components.}
    \label{fig:vg_basic}
\end{figure}


\paragraph{Sparse Voxel Octree}
Several operations on voxel grids benefit from using a spatial index, including radius searching and level of detail generation. We use a data structure called a sparse voxel octree (SVO) to achieve this. A normal octree recursively subdivides a volume into 8 cells, called octants. This operation results in a tree data structure, with nodes representing octants at a certain level of subsidivision. The root node of the tree structure represents the entire volume while the leaf nodes represent batches of 1 or more data points. In the case of a sparse voxel octree the leaf nodes represent individual voxels, with only the octants containing an occupied voxel represented in the tree. 

\begin{figure}[h]
    \centering
    \includegraphics*[width=.7\textwidth]{./fig/morton_code.pdf}
    \caption{2D example of morton codes.}
    \label{fig:vg_morton}
\end{figure}

To generate the SVO we first create a Morton order for the voxel grid, this is illustrated in figure \ref{fig:vg_morton}. A Morton order maps the three-dimensional coordinates of the voxels to one dimension while preserving locality. It does by interleaving the binary representation of the voxel's coordinates into a single binary string which is interpreted as a positive integer, a Morton code. The ascending sorted vector of Morton codes gives us the Morton order. We divide the Morton order into buckets with size 8, such that each bucket contains at most 8 Morton codes, with a maximum difference of 8. Each non-empty bucket represents a parent node of at most 8 child nodes in the octree. By recursively performing this step until only one bucket remains, the root node, we can construct an SVO. The SVO corresponding to the Morton code in figure \ref{fig:vg_morton} is shown in figure \ref{fig:vg_svo}.

\begin{figure}[h]
    \centering
    \includegraphics*[width=.5\textwidth]{./fig/svo.pdf}
    \caption{Example of a sparse voxel octree generated from the above Morton codes.}
    \label{fig:vg_svo}
\end{figure}

We denote the function that returns all \(n\) voxels within range \(r\) of a voxel as follows.

\begin{equation}
    radius: \mathbb{N}^{3},\ \mathbb{R} \mapsto \voxelset
\end{equation}

The voxels within a sphere around a point can be found by recursively intersecting the sphere with the octants of the SVO. If the sphere does not intersect with an octant then none of its leaf nodes do and the corresponding voxels are not within the sphere. If an octant does intersect with the sphere then its children are tested for intersection. The algorithm returns all leaf nodes that intersect with the sphere.

Levels of detail can be generated by using the occupied octants at the levels above leaf nodes as a simplified voxel grid. This can enable certain operations that are not computationally feasible at the original level of detail.

\paragraph{Voxel convolution}
Voxel convolution involves moving a sliding window, or kernel, over each voxel in the grid to retrieve its neighbourhood and then computing a new value for the voxel based on the weighted sum of its neighbours. We can define a kernel \(\mathcal{K}\) as a voxel grid with an associated weight for each voxel and an origin voxel \(\boldsymbol{o}_{\mathcal{K}}\).

\begin{equation}
weight: \mathbb{N}^{3} \mapsto \mathbb{R}
\end{equation}

\begin{equation}
\boldsymbol{o}_{\mathcal{K}} \in \mathbb{N}^{3}
\end{equation}

To apply a kernel to a voxel we first translate the kernel so that its origin lies on the voxel.

\begin{equation}
    \label{eq:kv}
\mathcal{K}_t = \{\boldsymbol{v_{\mathcal{K}}} + (\boldsymbol{v} - \boldsymbol{o_{\mathcal{K}}})\ |\ \boldsymbol{v_{\mathcal{K}}} \in \mathcal{K}\}
\end{equation}

We then get the property which we wish to convolve of each neighbour, multiply it by the neighbour's weight and sum it.

\begin{equation}
    \label{eq:kw}
    \mathcal{K}_{property}(\boldsymbol{v}) = \sum \{weight(\boldsymbol{v})\mathcal{V}_{property}(\boldsymbol{v})\ |\ \boldsymbol{v} \in \mathcal{K}_{t} \cap \mathcal{V}\}
\end{equation}

We denote the convolution of a property of every voxel in \(\mathcal{V}\) with \(\mathcal{K}\) as follows.

\begin{equation}
    \label{eq:c}
    \mathcal{V}_{property,\  \mathcal{K}} = \mathcal{V} * \mathcal{K}_{property} = \{\mathcal{K}_{property}(\boldsymbol{v}) \mid \boldsymbol{v} \in \mathcal{V}\}
\end{equation}


\paragraph{Neighbourhood graph}

The neighbourhood graph of a voxel grid represents the connectivity between voxels as undirected, unweighted graph. The nodes of the neighbourhood graph correspond to individual voxels and the edges to whether two voxels can be considered neighbours. Whether two voxels are neighbours is defined by a kernel which has only 1 or 0-valued weights. If, when applying the kernel to a voxel, another voxel within that kernel is occupied and the kernel's weight for that position is 1 then the two voxels are neighbours. The neighbourhood graph allows us to perform graph operations, such as identifying connected components, on voxel grids. Figure \ref{fig:vg_nbs} shows two commonly used kernels for constructing neighbourhood graphs, the Von Neumann and Moore neighbourhoods, also respectively known as the 6-neighbourhood and the 26-neighbourhood.

\begin{figure}[h]
    \centering
    \includegraphics*[width=.7\textwidth]{./fig/voxel_neighbourhood.pdf}
    \caption{Two common connectivity kernels. Note that the center voxel's weight is 0, as a voxel does not neighbour with itself.}
    \label{fig:vg_nbs}
\end{figure}

\newpage


\subsubsection{Topological map}
\Gls{topologicalmap}s are graph representations of an environment's structure, where nodes represent locally distinctive places and edges represent traversable paths between them  (see figure \ref{fig:topomap}) \citep{thrun_learning_1998,kuipers_robust_1988}. Topological maps are based on observations that cognitive maps, the mental maps used by humans to navigate within an environment, consist of multiple layers with a topological description of the environment being a fundamental component \citep{kuipers_robust_1988,kuipers_modeling_1978}. 

We denote a topological map as shown in equations \ref{eq:G}, \ref{eq:V} and \ref{eq:E}. The topological map consists of a graph \(G\), where nodes \(N\) represent distinctive places \(n_i\) and edges \(E\) represent the presence of a navigable path between neighbouring pairs of places \((n_j,n_k)\) that does not pass through any other places. Whether a path is navigable depends on who or what is navigating. For the purpose of this thesis a navigable path is a path that can be reasonably used by humans to walk from one room to another. Following this definition, only a part of the environment can be used as a navigable path. This includes the parts of the floor, stairs or ramps that are at sufficient distance from a wall, the ceiling or other obstructions.


\begin{equation}
    \label{eq:G}
    G=(N, E)
\end{equation}
\begin{equation}
    \label{eq:V}
    N=\{n_i\}_{i=1}^k
\end{equation}
\begin{equation}
    \label{eq:E}
    E=\{(n_j,n_k)_i\}_{i=1}^m,\ n_j \in N,\ n_k \in N,\ n_j \neq n_k\}
\end{equation}

Figure \ref{fig:topomap} shows an example topological map of a house with five rooms and their connectivity.

\begin{figure}[h]
    \centering
    \includegraphics*[width=.3\textwidth]{./fig/topological_map.pdf}
    \caption{Example of a topological map.}
    \label{fig:topomap}
\end{figure}

\pagebreak

\subsubsection{Topometric map}
A hybrid map representation combining both the topological and geometric characteristics of the environment. This map representation allows the end-user to use either topological or metric information depending on the needs of the situation, e.g. the topological layer can be used for large-scale navigation and abstract reasoning while the metric layer can be used for place recognition and obstacle avoidance. In the context of this thesis a topometric map refers to a graph representation of an indoor environment where the nodes represent rooms and their associated geometry as a voxel grid and the edges represent the navigability relationship between them. It is thus a hybrid representation of the environment that combines the properties of the voxel grid and the topological map which we described above. We denote a topometric map \(\topometricmap\) as shown in equation \ref{eq:topometricmap}, where \(\voxelgrid\) represents the complete geometry of the environment and \(G\) the topological graph.

\begin{equation}
    \label{eq:topometricmap}
    \topometricmap = (\voxelgrid,\ G),\ \voxelgrid=\{\voxel_{i}\}_{i=1}^{n}
\end{equation}

The topological graph, which we denote as shown in equation \ref{eq:place_subset}, consists of a set of nodes \(N\) and a set of edges \(E\). Each node \(n \in N\) represents a room and contains a subset of \(\voxelgrid\) that describes the geometry of that room. The nodes' subsets of \(\voxelgrid\) are not allowed to overlap, which means they represent a segmentation of \(\voxelgrid\).

\begin{equation}
    \label{eq:place_subset}
    G=(N,\ E),\ N=\{n_i\}_{i=1}^k,\ n \subset \voxelgrid
\end{equation}

Figure \ref{fig:topometricmap} shows an example of a topometric map of an indoor environment.

\begin{figure}[h]
    \centering
    \includegraphics*[width=.7\textwidth]{./fig/area_1_topo_01.png}
    \caption{Example of a topometric map.}
    \label{fig:topometricmap}
\end{figure}


